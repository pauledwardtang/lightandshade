//light source spawns light particles headed in a direction determined by its angle
//light source can be moved, and have its angle changed
class LightSource extends Unit{
  Body body;
  float spawnAngle;
  float radius;
  float x, y;
  ArrayList particles = new ArrayList();
  
  LightSource()
  {
    spawnAngle = radians(75);
    radius = 30;
    x = random(0, WIDTH);
    y = random(0, HEIGHT);
    makeBody(x, y, radius);
    body.setUserData(this);
  }
  
  //adds k new particles to the particle list.
  ArrayList spawn(int k)
  {
    float dir = random(radians(-spawnAngle/2), radians(spawnAngle/2));
    float xin, yin;
    
    for(int i = 0; i < k; i++)
     {
       //must be inside the LightSource
        xin = random(x-radius, x+radius);
        yin = random(y-radius, y+radius);
        particles.add(new LightParticle(xin, yin, dir)); 
        println("Particle spawned");
     }
     return particles;
  } 
  
  void display()
  {
    color cl;
    
    //light ring
    cl = color(255, 0, 0, 100);
    fill(cl);
    ellipse(x,y,radius*2,radius*2);
    noStroke();
    
    //Bulb
    cl = color(255, 255, 0);
    fill(cl);
    stroke(2);
    ellipse(x, y, radius*2, radius*2);
    noStroke();
    
    noFill();
  }
  
  //puts all particles in list on screen. Should be called after every spawn().
  void displayParticles()
  {
    for(int i = 0; i < particles.size(); i++)
    {
      LightParticle temp = (LightParticle) particles.get(i);
      if(temp.isAlive() == true)
      {
        temp.update();
        temp.display();
      }
      else
      {
        particles.remove(i);
      }
    }
  }
  void update()
  {
  }
  
  void makeBody(float x, float y, float r) {
    // Define a body
    BodyDef bd = new BodyDef();
    // Set its position
    bd.position = box2d.screenToWorld(x,y);
    body = box2d.world.createBody(bd);

    // Make the body's shape a circle
    CircleDef cd = new CircleDef();
    cd.radius = box2d.scaleScreenToWorld(r);
    cd.density = 1.0f;
    cd.friction = 0.01f;
    cd.restitution = 0.3f; // Restitution is bounciness
    body.createShape(cd);

    // Always do this at the end
    body.setMassFromShapes();
  }
  
  void draw(){
    color cl = color(255, 0, 0);
    fill(cl);
    stroke(2);
    ellipse(x, y, radius, radius);
    noFill();
    noStroke();
    
    
  }//end draw
}

//light particles only interact with obstacles and units
//light particles are generated by light sources, and move at a uniform speed
class LightParticle extends Particle{
  
  float dir;
  boolean alive;
  
  LightParticle(float xin, float yin, float dirIn){
    super(xin, yin, 2);
    dir = dirIn;//direction
    alive = true;
   // speed = 2;//this is the speed of light!
    makeBody(x, y, radius);
    body.setUserData(this);
  }
  
  boolean isAlive()
  {
    return alive;
  }
  
  void update(){
    if(x > width+radius || x < 0-radius || 
       y > height+radius || y < 0-radius){//exits bounds
        killBody();
        alive = false;
    }//end if
    else
      alive = true;    
  }//end update()
  
  void display()
  {
    Vec2 pos = box2d.getScreenPos(body);
    pushMatrix();
    translate(pos.x,pos.y);
    col = color(255, 255, 0);
    fill(col);
    stroke(0);
    strokeWeight(1);
    ellipse(0,0,r*2,r*2);
    popMatrix();
  }
  
  void collide()
  {
    
  }//checks for collisions
  
   void makeBody(float x, float y, float r) 
   {
     super.makeBody(x, y, r);
    
    CircleDef cd = new CircleDef();
    cd.density = 0.0f;
    cd.friction = 0.0f;
    cd.restitution = 1.0f; // Restitution is bounciness
    body.createShape(cd);
     
    // Give it a random initial velocity (and angular velocity)
    body.setLinearVelocity(new Vec2(8, 8));
    //body.setAngularVelocity(random(-10,10));
  }
}

////manages all light particles
//class LightSystem{
//  ArrayList particles;
//  LightSystem(LightSource source){
//    particles = source.spawn(20);
//  }
//}
